{"case_id": "k-9-5.600_0251e6efbbec", "project": "k-9-5.600", "file_path": "/Users/evol-lab/Documents/Projects/DSRS-research/roles-smells-metrics-package/data/SourceProjects/Mobile/k-9-5.600/k9mail-library/src/androidTest/java/com/fsck/k9/mail/ssl/TrustManagerFactoryTest.java", "package": "com.fsck.k9.mail.ssl", "class_name": "TrustManagerFactoryTest", "smell_type": "Deficient Encapsulation", "detector_reason": "The tool detected the smell in this class because the class exposes fields belonging to it with public accessibility. Following fields are declared with public accessiblity: MATCHING_HOST; NOT_MATCHING_HOST; PORT1; PORT2; K9_EXAMPLE_COM_CERT1; K9_EXAMPLE_COM_CERT2; CA_CERT; CERT3; LINUX_COM_FIRST_PARENT_CERT; LINUX_COM_CERT; mKeyStoreFile; mKeyStore; mCert1; mCert2; mCaCert; mCert3; mLinuxComFirstParentCert; mLinuxComCert", "metrics": {}, "code_excerpt": "public class TrustManagerFactoryTest {\n    public static final String MATCHING_HOST = \"k9.example.com\";\n    public static final String NOT_MATCHING_HOST = \"bla.example.com\";\n    public static final int PORT1 = 993;\n    public static final int PORT2 = 465;\n\n    private static final String K9_EXAMPLE_COM_CERT1 =\n              \"-----BEGIN CERTIFICATE-----\\n\"\n            + \"MIICCTCCAXICCQD/R0TV7d0C5TANBgkqhkiG9w0BAQUFADBJMQswCQYDVQQGEwJD\\n\"\n            + \"SDETMBEGA1UECBMKU29tZS1TdGF0ZTEMMAoGA1UEChMDSy05MRcwFQYDVQQDEw5r\\n\"\n            + \"OS5leGFtcGxlLmNvbTAeFw0xMTA5MDYxOTU3MzVaFw0yMTA5MDMxOTU3MzVaMEkx\\n\"\n            + \"CzAJBgNVBAYTAkNIMRMwEQYDVQQIEwpTb21lLVN0YXRlMQwwCgYDVQQKEwNLLTkx\\n\"\n            + \"FzAVBgNVBAMTDms5LmV4YW1wbGUuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\\n\"\n            + \"iQKBgQCp7FvHRaQaOIu3iyB5GB0PtPCxy/bLlBxBb8p9QsMimX2Yz3SNjWVUzU5N\\n\"\n            + \"ggpXmmeGopLAnvZlhWYSx0yIGWwPB44kGK5eaYDRWav+K+XXgdNCJij1UWPSmFwZ\\n\"\n            + \"hUoNbrahco5AFw0jC1qi+3Dht6Y64nfNzTOYTcm1Pz4tqXiADQIDAQABMA0GCSqG\\n\"\n            + \"SIb3DQEBBQUAA4GBAIPsgd6fuFRojSOAcUyhaoKaY5hXJf8d7R3AYWxcAPYmn6g7\\n\"\n            + \"3Zms+f7/CH0y/tM81oBTlq9ZLbrJyLzC7vG1pqWHMNaK7miAho22IRuk+HwvL6OA\\n\"\n            + \"uH3x3W1/mH4ci268cIFVmofID0nYLTqOxBTczfYhI7q0VBUXqv/bZ+3bVMSh\\n\"\n            + \"-----END CERTIFICATE-----\\n\";\n\n    private static final String K9_EXAMPLE_COM_CERT2 =\n              \"-----BEGIN CERTIFICATE-----\\n\"\n            + \"MIICCTCCAXICCQDMryqq0gZ80jANBgkqhkiG9w0BAQUFADBJMQswCQYDVQQGEwJD\\n\"\n            + \"SDETMBEGA1UECBMKU29tZS1TdGF0ZTEMMAoGA1UEChMDSy05MRcwFQYDVQQDEw5r\\n\"\n            + \"OS5leGFtcGxlLmNvbTAeFw0xMTA5MDYyMDAwNTVaFw0yMTA5MDMyMDAwNTVaMEkx\\n\"\n            + \"CzAJBgNVBAYTAkNIMRMwEQYDVQQIEwpTb21lLVN0YXRlMQwwCgYDVQQKEwNLLTkx\\n\"\n            + \"FzAVBgNVBAMTDms5LmV4YW1wbGUuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\\n\"\n            + \"iQKBgQDOLzRucC3tuXL/NthnGkgTnVn03balrvYPkABvvrG83Dpp5ipIC/iPsQvw\\n\"\n            + \"pvqypSNHqrloEB7o3obQ8tiRDtbOsNQ7gKJ+YoD1drDNClV0pBvr7mvRgA2AcDpw\\n\"\n            + \"CTLKwVIyKmE+rm3vl8CWFd9CqHcYQ3Mc1KXXasN4DEAzZ/sHRwIDAQABMA0GCSqG\\n\"\n            + \"SIb3DQEBBQUAA4GBAFDcHFpmZ9SUrc0WayrKNUpSaHLRG94uzIx0VUMLROcXEEWU\\n\"\n            + \"soRw1RfoSBkcy2SEjB4CAvex6qAiOT3ubXuL+BYFav/uU8JPWZ9ovSAYqBZ9aUJo\\n\"\n            + \"G6A2hvA1lpvP97qQ/NFaGQ38XqSykZamZwSx3PlZUM/i9S9n/3MfuuXWqtLC\\n\"\n            + \"-----END CERTIFICATE-----\\n\";\n\n    private static final String CA_CERT =\n            \"-----BEGIN CERTIFICATE-----\\n\"\n          + \"MIIDbTCCAlWgAwIBAgIJANCdQ+Cwnyg+MA0GCSqGSIb3DQEBBQUAME0xCzAJBgNV\\n\"\n          + \"BAYTAkNIMRMwEQYDVQQIDApTb21lLVN0YXRlMQwwCgYDVQQKDANLLTkxGzAZBgNV\\n\"\n          + \"BAMMEnRlc3QtY2EuazltYWlsLm9yZzAeFw0xMzEyMDIxMjUwNThaFw0yMzExMzAx\\n\"\n          + \"MjUwNThaME0xCzAJBgNVBAYTAkNIMRMwEQYDVQQIDApTb21lLVN0YXRlMQwwCgYD\\n\"\n          + \"VQQKDANLLTkxGzAZBgNVBAMMEnRlc3QtY2EuazltYWlsLm9yZzCCASIwDQYJKoZI\\n\"\n          + \"hvcNAQEBBQADggEPADCCAQoCggEBAJ+YLg9enfFk5eba6B3LtQzUE7GiR2tIpQSi\\n\"\n          + \"zHMtHzn8KUnRDiGwC8VnSuWCOX7hXyQ0P6i2+DVRVBYOAeDCNMZHOq1hRqI66B33\\n\"\n          + \"QqLfkBnJAIDeLqfqlgigHs1+//7eagVA6Z38ZFre3PFuKnK9NCwS+gz7PKw/poIG\\n\"\n          + \"/FZP+ltMlkwvPww4S8SMlY6RXXH09+S/uM8aG6DUBT298eoAXTbSEIeaNhwBHZPe\\n\"\n          + \"rXqqzd8QDAIE9BFXSkh/BQiVEFDPSBMSdmUzUAsT2aM8osntnKWY5/G7B60wutvA\\n\"\n          + \"jYCULgtR6lR6jIDbG3ECHVDsTWR+Pgl+h1zeyERhN5iG1ffOtLUCAwEAAaNQME4w\\n\"\n          + \"HQYDVR0OBBYEFBlUYiTGlOu9zIPx8Q13xcnDL5QpMB8GA1UdIwQYMBaAFBlUYiTG\\n\"\n          + \"lOu9zIPx8Q13xcnDL5QpMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEB\\n\"\n          + \"AJ6oC6O6I6p0vgA4+7dfyxKX745zl/fK6IVHV/GO75mLjVdyw00USbHGHAmZM5C6\\n\"\n          + \"eCKVV83m/Re5lHf8ZBjc+3rWdGCEjwyUwvDeUvzpcKF3wPxYDUOOqSI+np1cxj6q\\n\"\n          + \"6+XI5QXwyUObWtWyw1GOpLuFPbxny/TlRWvk8AfOaLANg3UhvITNZMdMHoQ2sJ3u\\n\"\n          + \"MrQ+CHe/Tal2MkwiCrYT91f3YWVaswiEAxpqxnwuSXnYyaJpqMCcA1txBDgX84FP\\n\"\n          + \"dSIM4ut+QltV2Tlx0lpH43dvttAwkPB+iL7ZF6zUki/Nq5aKyNoHOL88TACe18Lq\\n\"\n          + \"zOztD2HZfxhIz3uH2gXmqUo=\\n\"\n          + \"-----END CERTIFICATE-----\\n\";\n\n    private static final String CERT3 =\n            \"-----BEGIN CERTIFICATE-----\\n\"\n          + \"MIIDjDCCAnSgAwIBAgIBATANBgkqhkiG9w0BAQUFADBNMQswCQYDVQQGEwJDSDET\\n\"\n          + \"MBEGA1UECAwKU29tZS1TdGF0ZTEMMAoGA1UECgwDSy05MRswGQYDVQQDDBJ0ZXN0\\n\"\n          + \"LWNhLms5bWFpbC5vcmcwHhcNMTMxMjAyMTMxNzEyWhcNMjMxMTMwMTMxNzEyWjBJ\\n\"\n          + \"MQswCQYDVQQGEwJDSDETMBEGA1UECAwKU29tZS1TdGF0ZTEMMAoGA1UECgwDSy05\\n\"\n          + \"MRcwFQYDVQQDDA5rOS5leGFtcGxlLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEP\\n\"\n          + \"ADCCAQoCggEBAL9OvWtLcp6bd40Hai6A6cCmJRwn3mwcTB8E41iEQgQexqx/f9RR\\n\"\n          + \"BuQi2s80k/vXq8QU2GbwGiPkBBXMUHuiT27Lsoj8kMOnH5BXeKLaWDiMpvNqfent\\n\"\n          + \"UzBXSIOK6Yu9UtlU0MzAuYxXaunrXoS5Dejrbz743P9yW8hx7pANNU0Qfck+ekR7\\n\"\n          + \"Q4PWNgfbFHrnvcobzuFzJeWg8x9iTTsVGIaX9AVMjMUlIKvhhOWTlcTJHKzU67sp\\n\"\n          + \"OLzwH9IJ3hqwdmsgZu5D/2AZlYlpFk6AlnoxNhfy9m+T41P8+iWDYCJoxvf3d6gl\\n\"\n          + \"TlZ1FL0PzPReXeAgugyJ1qx5gJ9Vhf/rBaUCAwEAAaN7MHkwCQYDVR0TBAIwADAs\\n\"\n          + \"BglghkgBhvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYD\\n\"\n          + \"VR0OBBYEFPm9hbTbfmcnjjfOzrec/TrvsS5ZMB8GA1UdIwQYMBaAFBlUYiTGlOu9\\n\"\n          + \"zIPx8Q13xcnDL5QpMA0GCSqGSIb3DQEBBQUAA4IBAQAgvYQoCEklJNXBwLuWpSMx\\n\"\n          + \"CQrVxLI1XsYRzqMs0kUgM59OhwAPwdSR+UEuyXQ8QGKwSt1d//DkdhzQDATXSBYc\\n\"\n          + \"VHr16ocYPGNd/VNo7BoUCvykp3cCH3WxYYpAugXbLU8RBJzQwCM75SLQtFe20qfI\\n\"\n          + \"LErbrmKONtMk3Rfg6XtLLcaOVh1A3q13CKqDvwtZT4oo56EJOvkBkzlCvTuxJb6s\\n\"\n          + \"FD9pwROFpIN8O54C333tZzj4TDP4g9zb3sofAJ4U0osfQAXekZJdZETFGJsU6TIM\\n\"\n          + \"Dcf5/G8bZe2DnavBQfML1wI5d7NUWE8CWb95SsIvFXI0qZE0oIR+axBVl9u97uaO\\n\"\n          + \"-----END CERTIFICATE-----\\n\";\n\n    private static final String LINUX_COM_FIRST_PARENT_CERT =\n            \"-----BEGIN CERTIFICATE-----\\n\" +\n            \"MIIGNDCCBBygAwIBAgIBGzANBgkqhkiG9w0BAQsFADB9MQswCQYDVQQGEwJJTDEW\\n\" +\n            \"MBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwg\\n\" +\n            \"Q2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNh\\n\" +\n            \"dGlvbiBBdXRob3JpdHkwHhcNMDcxMDI0MjA1NzA5WhcNMTcxMDI0MjA1NzA5WjCB\\n\" +\n            \"jDELMAkGA1UEBhMCSUwxFjAUBgNVBAoTDVN0YXJ0Q29tIEx0ZC4xKzApBgNVBAsT\\n\" +\n            \"IlNlY3VyZSBEaWdpdGFsIENlcnRpZmljYXRlIFNpZ25pbmcxODA2BgNVBAMTL1N0\\n\" +\n            \"YXJ0Q29tIENsYXNzIDIgUHJpbWFyeSBJbnRlcm1lZGlhdGUgU2VydmVyIENBMIIB\\n\" +\n            \"IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4k85L6GMmoWtCA4IPlfyiAEh\\n\" +\n            \"G5SpbOK426oZGEY6UqH1D/RujOqWjJaHeRNAUS8i8gyLhw9l33F0NENVsTUJm9m8\\n\" +\n            \"H/rrQtCXQHK3Q5Y9upadXVACHJuRjZzArNe7LxfXyz6CnXPrB0KSss1ks3RVG7RL\\n\" +\n            \"hiEs93iHMuAW5Nq9TJXqpAp+tgoNLorPVavD5d1Bik7mb2VsskDPF125w2oLJxGE\\n\" +\n            \"d2H2wnztwI14FBiZgZl1Y7foU9O6YekO+qIw80aiuckfbIBaQKwn7UhHM7BUxkYa\\n\" +\n            \"8zVhwQIpkFR+ZE3EMFICgtffziFuGJHXuKuMJxe18KMBL47SLoc6PbQpZ4rEAwID\\n\" +\n            \"AQABo4IBrTCCAakwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYD\\n\" +\n            \"VR0OBBYEFBHbI0X9VMxqcW+EigPXvvcBLyaGMB8GA1UdIwQYMBaAFE4L7xqkQFul\\n\" +\n            \"F2mHMMo0aEPQQa7yMGYGCCsGAQUFBwEBBFowWDAnBggrBgEFBQcwAYYbaHR0cDov\\n\" +\n            \"L29jc3Auc3RhcnRzc2wuY29tL2NhMC0GCCsGAQUFBzAChiFodHRwOi8vd3d3LnN0\\n\" +\n            \"YXJ0c3NsLmNvbS9zZnNjYS5jcnQwWwYDVR0fBFQwUjAnoCWgI4YhaHR0cDovL3d3\\n\" +\n            \"dy5zdGFydHNzbC5jb20vc2ZzY2EuY3JsMCegJaAjhiFodHRwOi8vY3JsLnN0YXJ0\\n\" +\n            \"c3NsLmNvbS9zZnNjYS5jcmwwgYAGA1UdIAR5MHcwdQYLKwYBBAGBtTcBAgEwZjAu\\n\" +\n            \"BggrBgEFBQcCARYiaHR0cDovL3d3dy5zdGFydHNzbC5jb20vcG9saWN5LnBkZjA0\\n\" +\n            \"BggrBgEFBQcCARYoaHR0cDovL3d3dy5zdGFydHNzbC5jb20vaW50ZXJtZWRpYXRl\\n\" +\n            \"LnBkZjANBgkqhkiG9w0BAQsFAAOCAgEAbQjxXHkqUPtUY+u8NEFcuKMDITfjvGkl\\n\" +\n            \"LgrTuBW63grW+2AuDAZRo/066eNHs6QV4i5e4ujwPSR2dgggY7mOIIBmiDm2QRjF\\n\" +\n            \"5CROq6zDlIdqlsFZICkuONDNFpFjaPtZRTmuK1n6gywQgCNSIrbzjPcwR/jL/wow\\n\" +\n            \"bfwC9yGme1EeZRqvWy/HzFWacs7UMmWlRk6DTmpfPOPMJo5AxyTZCiCYQQeksV7x\\n\" +\n            \"UAeY0kWa+y/FV+eerOPUl6yy4jRHTk7tCySxrciZwYbd6YNLmeIQoUAdRC3CH3nT\\n\" +\n            \"B2/JYxltcgyGHMiPU3TtafZgLs8fvncv+wIF1YAF/OGqg8qmzoJ3ghM4upGdTMIu\\n\" +\n            \"8vADdmuLC/+dnbzknxX6QEGlWA8zojLUxVhGNfIFoizu/V/DyvSvYuxzzIkPECK5\\n\" +\n            \"gDoMoBTTMI/wnxXwulNPtfgF7/5AtDhA4GNAfB2SddxiNQAF7XkUHtMZ9ff3W6Xk\\n\" +\n            \"FldOG+NlLFqsDBG/KLckyFK36gq+FqNFCbmtmtXBGB5L1fDIeYzcMKG6hFQxhHS0\\n\" +\n            \"oqpdHhp2nWBfLlOnTNqIZNJzOH37OJE6Olk45LNFJtSrqIAZyCCfM6bQgoQvZuIa\\n\" +\n            \"xs9SIp+63ZMk9TxEaQj/KteaOyfaPXI9778U7JElMTz3Bls62mslV2I1C/A73Zyq\\n\" +\n            \"JZWQZ8NU4ds=\\n\" +\n            \"-----END CERTIFICATE-----\\n\";\n\n    private static final String LINUX_COM_CERT =\n        \"-----BEGIN CERTIFICATE-----\\n\" +\n        \"MIIGhjCCBW6gAwIBAgIDAmiWMA0GCSqGSIb3DQEBCwUAMIGMMQswCQYDVQQGEwJJ\\n\" +\n        \"TDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0\\n\" +\n        \"YWwgQ2VydGlmaWNhdGUgU2lnbmluZzE4MDYGA1UEAxMvU3RhcnRDb20gQ2xhc3Mg\\n\" +\n        \"MiBQcmltYXJ5IEludGVybWVkaWF0ZSBTZXJ2ZXIgQ0EwHhcNMTQwODIxMjEwMDI4\\n\" +\n        \"WhcNMTYwODIxMDY0NDE0WjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlm\\n\" +\n        \"b3JuaWExFjAUBgNVBAcTDVNhbiBGcmFuY2lzY28xHTAbBgNVBAoTFFRoZSBMaW51\\n\" +\n        \"eCBGb3VuZGF0aW9uMRQwEgYDVQQDFAsqLmxpbnV4LmNvbTEjMCEGCSqGSIb3DQEJ\\n\" +\n        \"ARYUaG9zdG1hc3RlckBsaW51eC5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw\\n\" +\n        \"ggEKAoIBAQCjvFjOigXyqkSiVv0vz1CSDg08iilLnj8gRFRoRMA6fFWhQTp4QGLV\\n\" +\n        \"1li5VMEQdZ/vyqTWjmB+FFkuTsBjFDg6gG3yw6DQBGyyM06A1dT9YKUa7LqxOxQr\\n\" +\n        \"KhNOacPS/pAupAZ5jOO7fcZwIcpKcKEjjhHn7GXEVvb+K996TMA0vDYcp1lgXtil\\n\" +\n        \"7Ij+1GUSA29NrnCZXUun2c5nS7OulRYcgtRyZBa13zfyaVJtEIl14ClP9gsLa/5u\\n\" +\n        \"eXzZD71Jj48ZNbiKRThiUZ5FkEnljjSQa25Hr5g9DXY2JvI1r8OJOCUR8jPiRyNs\\n\" +\n        \"Kgc1ZG0fibm9VoHjokUZ2aQxyQJP/C1TAgMBAAGjggLlMIIC4TAJBgNVHRMEAjAA\\n\" +\n        \"MAsGA1UdDwQEAwIDqDAdBgNVHSUEFjAUBggrBgEFBQcDAgYIKwYBBQUHAwEwHQYD\\n\" +\n        \"VR0OBBYEFI0nMnIXZOz02MlXPh2g9aHesvPPMB8GA1UdIwQYMBaAFBHbI0X9VMxq\\n\" +\n        \"cW+EigPXvvcBLyaGMCEGA1UdEQQaMBiCCyoubGludXguY29tgglsaW51eC5jb20w\\n\" +\n        \"ggFWBgNVHSAEggFNMIIBSTAIBgZngQwBAgIwggE7BgsrBgEEAYG1NwECAzCCASow\\n\" +\n        \"LgYIKwYBBQUHAgEWImh0dHA6Ly93d3cuc3RhcnRzc2wuY29tL3BvbGljeS5wZGYw\\n\" +\n        \"gfcGCCsGAQUFBwICMIHqMCcWIFN0YXJ0Q29tIENlcnRpZmljYXRpb24gQXV0aG9y\\n\" +\n        \"aXR5MAMCAQEagb5UaGlzIGNlcnRpZmljYXRlIHdhcyBpc3N1ZWQgYWNjb3JkaW5n\\n\" +\n        \"IHRvIHRoZSBDbGFzcyAyIFZhbGlkYXRpb24gcmVxdWlyZW1lbnRzIG9mIHRoZSBT\\n\" +\n        \"dGFydENvbSBDQSBwb2xpY3ksIHJlbGlhbmNlIG9ubHkgZm9yIHRoZSBpbnRlbmRl\\n\" +\n        \"ZCBwdXJwb3NlIGluIGNvbXBsaWFuY2Ugb2YgdGhlIHJlbHlpbmcgcGFydHkgb2Js\\n\" +\n        \"aWdhdGlvbnMuMDUGA1UdHwQuMCwwKqAooCaGJGh0dHA6Ly9jcmwuc3RhcnRzc2wu\\n\" +\n        \"Y29tL2NydDItY3JsLmNybDCBjgYIKwYBBQUHAQEEgYEwfzA5BggrBgEFBQcwAYYt\\n\" +\n        \"aHR0cDovL29jc3Auc3RhcnRzc2wuY29tL3N1Yi9jbGFzczIvc2VydmVyL2NhMEIG\\n\" +\n        \"CCsGAQUFBzAChjZodHRwOi8vYWlhLnN0YXJ0c3NsLmNvbS9jZXJ0cy9zdWIuY2xh\\n\" +\n        \"c3MyLnNlcnZlci5jYS5jcnQwIwYDVR0SBBwwGoYYaHR0cDovL3d3dy5zdGFydHNz\\n\" +\n        \"bC5jb20vMA0GCSqGSIb3DQEBCwUAA4IBAQBVkvlwVLfnTNZh1c8j+PQ1t2n6x1dh\\n\" +\n        \"tQtZiAYWKvZwi+XqLwU8q2zMxKrTDuqyEVyfCtWCiC1Vkpz72pcyXz2dKu7F7ZVL\\n\" +\n        \"86uVHcc1jAGmL59UCXz8LFbfAMcoVQW1f2WtNwsa/WGnPUes3jFSec+shB+XCpvE\\n\" +\n        \"WU6mfcZD5TyvbC79Kn5e3Iq+B4DaXhU/BXASRbORgYd8C+dqj++w0PAcMrmjn3D6\\n\" +\n        \"EmL1ofqpQ8wCJd5C1b5Fr4RbbYpK8v8AASRcp2Qj9WJjyV882FvXOOFj5V2Jjcnh\\n\" +\n        \"G0h67ElS/klu9rPaZ+vr3iIB56wvk08O2Wq1IND3sN+Ke3UsvuPqDxAv\\n\" +\n        \"-----END CERTIFICATE-----\\n\";\n\n    private File mKeyStoreFile;\n    private LocalKeyStore mKeyStore;\n    private X509Certificate mCert1;\n    private X509Certificate mCert2;\n    private X509Certificate mCaCert;\n    private X509Certificate mCert3;\n    private X509Certificate mLinuxComFirstParentCert;\n    private X509Certificate mLinuxComCert;\n\n\n    public TrustManagerFactoryTest() throws CertificateException {\n        mCert1 = loadCert(K9_EXAMPLE_COM_CERT1);\n        mCert2 = loadCert(K9_EXAMPLE_COM_CERT2);\n        mCaCert = loadCert(CA_CERT);\n        mCert3 = loadCert(CERT3);\n        mLinuxComFirstParentCert = loadCert(LINUX_COM_FIRST_PARENT_CERT);\n        mLinuxComCert = loadCert(LINUX_COM_CERT);\n    }\n\n    private X509Certificate loadCert(String encodedCert) throws CertificateException {\n        CertificateFactory certFactory = CertificateFactory.getInstance(\"X509\");\n        return (X509Certificate) certFactory.generateCertificate(\n                new ByteArrayInputStream(encodedCert.getBytes()));\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        mKeyStoreFile = File.createTempFile(\"localKeyStore\", null,\n                InstrumentationRegistry.getTargetContext().getCacheDir());\n        mKeyStore = LocalKeyStore.getInstance();\n        mKeyStore.setKeyStoreFile(mKeyStoreFile);\n    }\n\n    @After\n    public void tearDown() {\n        if (mKeyStoreFile.exists() && !mKeyStoreFile.delete()) {\n            throw new RuntimeException(\"Unable to delete key store file: \" + mKeyStoreFile.getAbsolutePath());\n        }\n    }\n\n    /**\n     * Checks if TrustManagerFactory supports a host with different certificates for different\n     * services (e.g. SMTP and IMAP).\n     *\n     * <p>\n     * This test is to make sure entries in the keystore file aren't overwritten.\n     * See <a href=\"https://code.google.com/p/k9mail/issues/detail?id=1326\">Issue 1326</a>.\n     * </p>\n     *\n     * @throws Exception\n     *         if anything goes wrong\n     */\n    @Test\n    public void testDifferentCertificatesOnSameServer() throws Exception {\n        mKeyStore.addCertificate(NOT_MATCHING_HOST, PORT1, mCert1);\n        mKeyStore.addCertificate(NOT_MATCHING_HOST, PORT2, mCert2);\n\n        X509TrustManager trustManager1 = TrustManagerFactory.get(NOT_MATCHING_HOST, PORT1);\n        X509TrustManager trustManager2 = TrustManagerFactory.get(NOT_MATCHING_HOST, PORT2);\n        trustManager2.checkServerTrusted(new X509Certificate[] { mCert2 }, \"authType\");\n        trustManager1.checkServerTrusted(new X509Certificate[] { mCert1 }, \"authType\");\n    }\n\n    @Test\n    public void testSelfSignedCertificateMatchingHost() throws Exception {\n        mKeyStore.addCertificate(MATCHING_HOST, PORT1, mCert1);\n        X509TrustManager trustManager = TrustManagerFactory.get(MATCHING_HOST, PORT1);\n        trustManager.checkServerTrusted(new X509Certificate[] { mCert1 }, \"authType\");\n    }\n\n    @Test\n    public void testSelfSignedCertificateNotMatchingHost() throws Exception {\n        mKeyStore.addCertificate(NOT_MATCHING_HOST, PORT1, mCert1);\n        X509TrustManager trustManager = TrustManagerFactory.get(NOT_MATCHING_HOST, PORT1);\n        trustManager.checkServerTrusted(new X509Certificate[] { mCert1 }, \"authType\");\n    }\n\n    @Test\n    public void testWrongCertificate() throws Exception {\n        mKeyStore.addCertificate(MATCHING_HOST, PORT1, mCert1);\n        X509TrustManager trustManager = TrustManagerFactory.get(MATCHING_HOST, PORT1);\n        assertCertificateRejection(trustManager, new X509Certificate[] { mCert2 });\n    }\n\n    @Test\n    public void testCertificateOfOtherHost() throws Exception {\n        mKeyStore.addCertificate(MATCHING_HOST, PORT1, mCert1);\n        mKeyStore.addCertificate(MATCHING_HOST, PORT2, mCert2);\n\n        X509TrustManager trustManager = TrustManagerFactory.get(MATCHING_HOST, PORT1);\n        assertCertificateRejection(trustManager, new X509Certificate[] { mCert2 });\n    }\n\n    @Test\n    public void testUntrustedCertificateChain() throws Exception {\n        X509TrustManager trustManager = TrustManagerFactory.get(MATCHING_HOST, PORT1);\n        assertCertificateRejection(trustManager, new X509Certificate[] { mCert3, mCaCert });\n    }\n\n    @Test\n    public void testLocallyTrustedCertificateChain() throws Exception {\n        mKeyStore.addCertificate(MATCHING_HOST, PORT1, mCert3);\n\n        X509TrustManager trustManager = TrustManagerFactory.get(MATCHING_HOST, PORT1);\n        trustManager.checkServerTrusted(new X509Certificate[] { mCert3, mCaCert }, \"authType\");\n    }\n\n    @Test\n    public void testLocallyTrustedCertificateChainNotMatchingHost() throws Exception {\n        mKeyStore.addCertificate(NOT_MATCHING_HOST, PORT1, mCert3);\n\n        X509TrustManager trustManager = TrustManagerFactory.get(NOT_MATCHING_HOST, PORT1);\n        trustManager.checkServerTrusted(new X509Certificate[] { mCert3, mCaCert }, \"authType\");\n    }\n\n    @Test\n    public void testGloballyTrustedCertificateChain() throws Exception {\n        X509TrustManager trustManager = TrustManagerFactory.get(\"www.linux.com\", PORT1);\n        X509Certificate[] certificates = new X509Certificate[] { mLinuxComCert, mLinuxComFirstParentCert};\n        trustManager.checkServerTrusted(certificates, \"authType\");\n    }\n\n    @Test\n    public void testGloballyTrustedCertificateNotMatchingHost() throws Exception {\n        X509TrustManager trustManager = TrustManagerFactory.get(NOT_MATCHING_HOST, PORT1);\n        assertCertificateRejection(trustManager, new X509Certificate[] { mLinuxComCert, mLinuxComFirstParentCert});\n    }\n\n    @Test\n    public void testGloballyTrustedCertificateNotMatchingHostOverride() throws Exception {\n        mKeyStore.addCertificate(MATCHING_HOST, PORT1, mLinuxComCert);\n\n        X509TrustManager trustManager = TrustManagerFactory.get(MATCHING_HOST, PORT1);\n        X509Certificate[] certificates = new X509Certificate[] { mLinuxComCert, mLinuxComFirstParentCert};\n        trustManager.checkServerTrusted(certificates, \"authType\");\n    }\n\n    private void assertCertificateRejection(X509TrustManager trustManager,\n            X509Certificate[] certificates) {\n        boolean certificateValid;\n        try {\n            trustManager.checkServerTrusted(certificates, \"authType\");\n            certificateValid = true;\n        } catch (CertificateException e) {\n            certificateValid = false;\n        }\n        assertFalse(\"The certificate should have been rejected but wasn't\", certificateValid);\n    }\n\n    @Test\n    public void testKeyStoreLoading() throws Exception {\n        mKeyStore.addCertificate(MATCHING_HOST, PORT1, mCert1);\n        mKeyStore.addCertificate(NOT_MATCHING_HOST, PORT2, mCert2);\n        assertTrue(mKeyStore.isValidCertificate(mCert1, MATCHING_HOST, PORT1));\n        assertTrue(mKeyStore.isValidCertificate(mCert2, NOT_MATCHING_HOST, PORT2));\n\n        // reload store from same file\n        mKeyStore.setKeyStoreFile(mKeyStoreFile);\n        assertTrue(mKeyStore.isValidCertificate(mCert1, MATCHING_HOST, PORT1));\n        assertTrue(mKeyStore.isValidCertificate(mCert2, NOT_MATCHING_HOST, PORT2));\n\n        // reload store from empty file\n        if (mKeyStoreFile.exists() && !mKeyStoreFile.delete()) {\n            throw new RuntimeException(\"Unable to delete key store file: \" + mKeyStoreFile.getAbsolutePath());\n        }\n        mKeyStore.setKeyStoreFile(mKeyStoreFile);\n        assertFalse(mKeyStore.isValidCertificate(mCert1, MATCHING_HOST, PORT1));\n        assertFalse(mKeyStore.isValidCertificate(mCert2, NOT_MATCHING_HOST, PORT2));\n    }\n}", "excerpt_strategy": "line_based_class_block"}
{"case_id": "k-9-5.600_4f505b74f341", "project": "k-9-5.600", "file_path": "/Users/evol-lab/Documents/Projects/DSRS-research/roles-smells-metrics-package/data/SourceProjects/Mobile/k-9-5.600/k9mail-library/src/main/java/com/fsck/k9/mail/ssl/LocalKeyStore.java", "package": "com.fsck.k9.mail.ssl", "class_name": "LocalKeyStore.LocalKeyStoreHolder", "smell_type": "Unnecessary Abstraction", "detector_reason": "The tool detected the smell in this class because the class contains only a few data members without any method implementation that indicates that the abstraction might not be required. Following fields are declared in this class: INSTANCE", "metrics": {}, "code_excerpt": "    private static class LocalKeyStoreHolder {\n        static final LocalKeyStore INSTANCE = new LocalKeyStore();\n    }", "excerpt_strategy": "line_based_class_block"}
{"case_id": "k-9-5.600_99b09cb21a32", "project": "k-9-5.600", "file_path": "/Users/evol-lab/Documents/Projects/DSRS-research/roles-smells-metrics-package/data/SourceProjects/Mobile/k-9-5.600/k9mail-library/src/main/java/com/fsck/k9/mail/ssl/LocalKeyStore.java", "package": "com.fsck.k9.mail.ssl", "class_name": "LocalKeyStore.LocalKeyStoreHolder", "smell_type": "Unutilized Abstraction", "detector_reason": "The tool detected the smell in this class because this class is potentially unused. (Please ignore the smell if the reported class is auto-generated and/or used to serve a specific known purpose.)", "metrics": {}, "code_excerpt": "    private static class LocalKeyStoreHolder {\n        static final LocalKeyStore INSTANCE = new LocalKeyStore();\n    }", "excerpt_strategy": "line_based_class_block"}
{"case_id": "k-9-5.600_8c7565a086d5", "project": "k-9-5.600", "file_path": "/Users/evol-lab/Documents/Projects/DSRS-research/roles-smells-metrics-package/data/SourceProjects/Mobile/k-9-5.600/k9mail-library/src/main/java/com/fsck/k9/mail/ssl/KeyChainKeyManager.java", "package": "com.fsck.k9.mail.ssl", "class_name": "KeyChainKeyManager", "smell_type": "Unutilized Abstraction", "detector_reason": "The tool detected the smell in this class because this class is potentially unused. (Please ignore the smell if the reported class is auto-generated and/or used to serve a specific known purpose.)", "metrics": {}, "code_excerpt": "class KeyChainKeyManager extends X509ExtendedKeyManager {\n\n    private static PrivateKey sClientCertificateReferenceWorkaround;\n\n\n    private static synchronized void savePrivateKeyReference(PrivateKey privateKey) {\n        if (sClientCertificateReferenceWorkaround == null) {\n            sClientCertificateReferenceWorkaround = privateKey;\n        }\n    }\n\n\n    private final String mAlias;\n    private final X509Certificate[] mChain;\n    private final PrivateKey mPrivateKey;\n\n\n    /**\n     * @param alias  Must not be null nor empty\n     * @throws MessagingException\n     *          Indicates an error in retrieving the certificate for the alias\n     *          (likely because the alias is invalid or the certificate was deleted)\n     */\n    public KeyChainKeyManager(Context context, String alias) throws MessagingException {\n        mAlias = alias;\n\n        try {\n            mChain = fetchCertificateChain(context, alias);\n            mPrivateKey = fetchPrivateKey(context, alias);\n        } catch (KeyChainException e) {\n            // The certificate was possibly deleted.  Notify user of error.\n            throw new CertificateValidationException(e.getMessage(), RetrievalFailure, alias);\n        } catch (InterruptedException e) {\n            throw new CertificateValidationException(e.getMessage(), RetrievalFailure, alias);\n        }\n    }\n\n    private X509Certificate[] fetchCertificateChain(Context context, String alias)\n            throws KeyChainException, InterruptedException, MessagingException {\n\n        X509Certificate[] chain = KeyChain.getCertificateChain(context, alias);\n        if (chain == null || chain.length == 0) {\n            throw new MessagingException(\"No certificate chain found for: \" + alias);\n        }\n        try {\n            for (X509Certificate certificate : chain) {\n                certificate.checkValidity();\n            }\n        } catch (CertificateException e) {\n            throw new CertificateValidationException(e.getMessage(), Reason.Expired, alias);\n        }\n\n        return chain;\n    }\n\n    private PrivateKey fetchPrivateKey(Context context, String alias) throws KeyChainException,\n            InterruptedException, MessagingException {\n\n        PrivateKey privateKey = KeyChain.getPrivateKey(context, alias);\n        if (privateKey == null) {\n            throw new MessagingException(\"No private key found for: \" + alias);\n        }\n\n        /*\n         * We need to keep reference to the first private key retrieved so\n         * it won't get garbage collected. If it will then the whole app\n         * will crash on Android < 4.2 with \"Fatal signal 11 code=1\". See\n         * https://code.google.com/p/android/issues/detail?id=62319\n         */\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\n            savePrivateKeyReference(privateKey);\n        }\n\n        return privateKey;\n    }\n\n    @Override\n    public String chooseClientAlias(String[] keyTypes, Principal[] issuers, Socket socket) {\n        return chooseAlias(keyTypes, issuers);\n    }\n\n    @Override\n    public X509Certificate[] getCertificateChain(String alias) {\n        return (mAlias.equals(alias) ? mChain : null);\n    }\n\n    @Override\n    public PrivateKey getPrivateKey(String alias) {\n        return (mAlias.equals(alias) ? mPrivateKey : null);\n    }\n\n    @Override\n    public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {\n        return chooseAlias(new String[] { keyType }, issuers);\n    }\n\n    @Override\n    public String[] getClientAliases(String keyType, Principal[] issuers) {\n        final String al = chooseAlias(new String[] { keyType }, issuers);\n        return (al == null ? null : new String[] { al });\n    }\n\n    @Override\n    public String[] getServerAliases(String keyType, Principal[] issuers) {\n        final String al = chooseAlias(new String[] { keyType }, issuers);\n        return (al == null ? null : new String[] { al });\n    }\n\n    @Override\n    public String chooseEngineClientAlias(String[] keyTypes, Principal[] issuers, SSLEngine engine) {\n        return chooseAlias(keyTypes, issuers);\n    }\n\n    @Override\n    public String chooseEngineServerAlias(String keyType, Principal[] issuers, SSLEngine engine) {\n        return chooseAlias(new String[] { keyType }, issuers);\n    }\n\n    private String chooseAlias(String[] keyTypes, Principal[] issuers) {\n        if (keyTypes == null || keyTypes.length == 0) {\n            return null;\n        }\n        final X509Certificate cert = mChain[0];\n        final String certKeyAlg = cert.getPublicKey().getAlgorithm();\n        final String certSigAlg = cert.getSigAlgName().toUpperCase(Locale.US);\n        for (String keyAlgorithm : keyTypes) {\n            if (keyAlgorithm == null) {\n                continue;\n            }\n            final String sigAlgorithm;\n            // handle cases like EC_EC and EC_RSA\n            int index = keyAlgorithm.indexOf('_');\n            if (index == -1) {\n                sigAlgorithm = null;\n            } else {\n                sigAlgorithm = keyAlgorithm.substring(index + 1);\n                keyAlgorithm = keyAlgorithm.substring(0, index);\n            }\n            // key algorithm does not match\n            if (!certKeyAlg.equals(keyAlgorithm)) {\n                continue;\n            }\n            /*\n             * TODO find a more reliable test for signature\n             * algorithm. Unfortunately value varies with\n             * provider. For example for \"EC\" it could be\n             * \"SHA1WithECDSA\" or simply \"ECDSA\".\n             */\n            // sig algorithm does not match\n            if (sigAlgorithm != null && certSigAlg != null\n                    && !certSigAlg.contains(sigAlgorithm)) {\n                continue;\n            }\n            // no issuers to match\n            if (issuers == null || issuers.length == 0) {\n                return mAlias;\n            }\n            List<Principal> issuersList = Arrays.asList(issuers);\n            // check that a certificate in the chain was issued by one of the specified issuers\n            for (X509Certificate certFromChain : mChain) {\n                /*\n                 * Note use of X500Principal from\n                 * getIssuerX500Principal as opposed to Principal\n                 * from getIssuerDN. Principal.equals test does\n                 * not work in the case where\n                 * xcertFromChain.getIssuerDN is a bouncycastle\n                 * org.bouncycastle.jce.X509Principal.\n                 */\n                X500Principal issuerFromChain = certFromChain.getIssuerX500Principal();\n                if (issuersList.contains(issuerFromChain)) {\n                    return mAlias;\n                }\n            }\n            Timber.w(\"Client certificate %s not issued by any of the requested issuers\", mAlias);\n            return null;\n        }\n        Timber.w(\"Client certificate %s does not match any of the requested key types\", mAlias);\n        return null;\n    }\n}", "excerpt_strategy": "line_based_class_block"}
{"case_id": "k-9-5.600_ca7e2263cb4d", "project": "k-9-5.600", "file_path": "/Users/evol-lab/Documents/Projects/DSRS-research/roles-smells-metrics-package/data/SourceProjects/Mobile/k-9-5.600/k9mail-library/src/main/java/com/fsck/k9/mail/ssl/TrustManagerFactory.java", "package": "com.fsck.k9.mail.ssl", "class_name": "TrustManagerFactory.SecureX509TrustManager", "smell_type": "Unnecessary Abstraction", "detector_reason": "The tool detected the smell in this class because the class contains only a few data members without any method implementation that indicates that the abstraction might not be required. Following fields are declared in this class: mTrustManager; mHost; mPort", "metrics": {}, "code_excerpt": "    private static class SecureX509TrustManager implements X509TrustManager {\n        private static final Map<String, SecureX509TrustManager> mTrustManager =\n            new HashMap<String, SecureX509TrustManager>();\n\n        private final String mHost;\n        private final int mPort;\n\n        private SecureX509TrustManager(String host, int port) {\n            mHost = host;\n            mPort = port;\n        }\n\n        public synchronized static X509TrustManager getInstance(String host, int port) {\n            String key = host + \":\" + port;\n            SecureX509TrustManager trustManager;\n            if (mTrustManager.containsKey(key)) {\n                trustManager = mTrustManager.get(key);\n            } else {\n                trustManager = new SecureX509TrustManager(host, port);\n                mTrustManager.put(key, trustManager);\n            }\n\n            return trustManager;\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType)\n        throws CertificateException {\n            defaultTrustManager.checkClientTrusted(chain, authType);\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType)\n                throws CertificateException {\n            String message = null;\n            X509Certificate certificate = chain[0];\n\n            Throwable cause = null;\n\n            try {\n                defaultTrustManager.checkServerTrusted(chain, authType);\n                new StrictHostnameVerifier().verify(mHost, certificate);\n                return;\n            } catch (CertificateException e) {\n                // cert. chain can't be validated\n                message = e.getMessage();\n                cause = e;\n            } catch (SSLException e) {\n                // host name doesn't match certificate\n                message = e.getMessage();\n                cause = e;\n            }\n\n            // Check the local key store if we couldn't verify the certificate using the global\n            // key store or if the host name doesn't match the certificate name\n            if (!keyStore.isValidCertificate(certificate, mHost, mPort)) {\n                throw new CertificateChainException(message, chain, cause);\n            }\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return defaultTrustManager.getAcceptedIssuers();\n        }\n\n    }", "excerpt_strategy": "line_based_class_block"}
{"case_id": "k-9-5.600_f5dbd4de32fe", "project": "k-9-5.600", "file_path": "/Users/evol-lab/Documents/Projects/DSRS-research/roles-smells-metrics-package/data/SourceProjects/Mobile/k-9-5.600/k9mail-library/src/main/java/com/fsck/k9/mail/ssl/TrustManagerFactory.java", "package": "com.fsck.k9.mail.ssl", "class_name": "TrustManagerFactory.SecureX509TrustManager", "smell_type": "Unutilized Abstraction", "detector_reason": "The tool detected the smell in this class because this class is potentially unused. (Please ignore the smell if the reported class is auto-generated and/or used to serve a specific known purpose.)", "metrics": {}, "code_excerpt": "    private static class SecureX509TrustManager implements X509TrustManager {\n        private static final Map<String, SecureX509TrustManager> mTrustManager =\n            new HashMap<String, SecureX509TrustManager>();\n\n        private final String mHost;\n        private final int mPort;\n\n        private SecureX509TrustManager(String host, int port) {\n            mHost = host;\n            mPort = port;\n        }\n\n        public synchronized static X509TrustManager getInstance(String host, int port) {\n            String key = host + \":\" + port;\n            SecureX509TrustManager trustManager;\n            if (mTrustManager.containsKey(key)) {\n                trustManager = mTrustManager.get(key);\n            } else {\n                trustManager = new SecureX509TrustManager(host, port);\n                mTrustManager.put(key, trustManager);\n            }\n\n            return trustManager;\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType)\n        throws CertificateException {\n            defaultTrustManager.checkClientTrusted(chain, authType);\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType)\n                throws CertificateException {\n            String message = null;\n            X509Certificate certificate = chain[0];\n\n            Throwable cause = null;\n\n            try {\n                defaultTrustManager.checkServerTrusted(chain, authType);\n                new StrictHostnameVerifier().verify(mHost, certificate);\n                return;\n            } catch (CertificateException e) {\n                // cert. chain can't be validated\n                message = e.getMessage();\n                cause = e;\n            } catch (SSLException e) {\n                // host name doesn't match certificate\n                message = e.getMessage();\n                cause = e;\n            }\n\n            // Check the local key store if we couldn't verify the certificate using the global\n            // key store or if the host name doesn't match the certificate name\n            if (!keyStore.isValidCertificate(certificate, mHost, mPort)) {\n                throw new CertificateChainException(message, chain, cause);\n            }\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return defaultTrustManager.getAcceptedIssuers();\n        }\n\n    }", "excerpt_strategy": "line_based_class_block"}
